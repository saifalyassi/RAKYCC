'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var ResolveType;
(function (ResolveType) {
    ResolveType["VariantMap"] = "variant-map";
    ResolveType["ContentMap"] = "content-map";
    ResolveType["Content"] = "content";
})(ResolveType || (ResolveType = {}));

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var camelCase$1 = {};

var constants = {};

Object.defineProperty(constants, "__esModule", { value: true });
constants.blankCaseRegExp = void 0;
constants.blankCaseRegExp = /[-\.\s\+,\_]+/;

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.camelCase = void 0;
const constants_1 = constants;
const camelCase = (val) => String(val)
    .split(constants_1.blankCaseRegExp)
    .filter(str => str.length > 0)
    .map((str, index) => {
    if (index < 1)
        return str;
    return str.substring(0, 1).toUpperCase() + str.substring(1);
})
    .join('');
exports.camelCase = camelCase;
exports.default = exports.camelCase;
}(camelCase$1));

var camelCase = /*@__PURE__*/getDefaultExportFromCjs(camelCase$1);

const numberStartedRegExp = /^[0-9]/;
const numberOnlyRegExp = /^[0-9]$/;
const ignoredPropNames = ['title', 'version', 'style', 'content'];
const PRIMARY_CURRENT_COLOR = 'currentColor';
const createRandomId = (base = 0x100000) => (((1 + Math.random()) * base) | 0).toString(24);
const filterNonNumberStartedString = (str) => !String(str).match(numberStartedRegExp);
const filterNubmerOnlyString = (str) => !!String(str).match(numberOnlyRegExp);
const filterIgnoredPropNames = (name) => !ignoredPropNames.includes(name);
const filterNonEmptyString = (name) => name !== '' && name !== null && name !== undefined;
const removeUnit = (str, unit = 'px') => (!str ? '' : String(str).replace(unit, ''));
const appendUnit = (str, unit = 'px') => {
    if (filterNubmerOnlyString(str))
        return `${str}${unit}`;
    return String(str);
};
const propNameFiltering = (name) => filterNonNumberStartedString(name) && filterNonEmptyString(name) && filterIgnoredPropNames(name);
/**
 * Used for create the runner for converting react used props
 * @param namesRemap {Record<string, string | null>} Swap the original name into new props name or remove it when mattched
 * @param attrs
 * @param originalContent
 * @returns
 */
const createConvertReactProps = (namesRemap, { convertCamelCase = true } = {}) => (attrs, originalContent = {}, { allowNonWhitelistProp = true } = {}) => {
    const exportedProps = Object.assign({}, originalContent);
    const newAttrs = Object.keys(attrs)
        .filter(propNameFiltering)
        .reduce((curProps, sourceName) => {
        let targetName = !namesRemap ? sourceName : namesRemap[sourceName];
        if (!targetName && allowNonWhitelistProp)
            targetName = sourceName;
        if (targetName) {
            const convertedName = convertCamelCase && !namesRemap[sourceName] ? camelCase(targetName) : targetName;
            curProps[convertedName] = attrs[targetName] || attrs[sourceName];
        }
        return curProps;
    }, exportedProps);
    return newAttrs;
};
/**
 * Getting viewBox string from properties, default width height is 24
 * @param {IconSVG} content SVG Content
 * @returns {string}
 */
const getViewboxValue = (content) => {
    const { attrs, width = 24, height = 24 } = content;
    const { viewBox, width: orgWidth, height: orgHeight } = attrs || {};
    const _viewBox = viewBox || `0 0 ${removeUnit(orgWidth || width)} ${removeUnit(orgHeight || height)}`;
    return _viewBox;
};
const getContentFromIconProps = (props) => {
    const { content, name, resolveType: type } = props;
    if (content && (type === ResolveType.Content || !type)) {
        return content;
    }
    const map = resolveIconsMap(props);
    if (name && map && map[name]) {
        return map[name];
    }
    return null;
};
const resolveIconsMap = (props) => {
    const { resolveType: type, variantsMap, map, variant, defaultVariant } = props;
    if (type === ResolveType.VariantMap) {
        if (variantsMap && variant && variantsMap[variant]) {
            return variantsMap[variant];
        }
        if (variantsMap && defaultVariant && variantsMap[defaultVariant] && variantsMap[defaultVariant]) {
            return variantsMap[defaultVariant];
        }
    }
    if (type === ResolveType.ContentMap) {
        if (variantsMap && variant && variantsMap[variant] && variantsMap[variant]) {
            return variantsMap[variant];
        }
        if (map) {
            return map;
        }
    }
    return null;
};
function showDebugWarning(...rest) {
    // if (process.env.NODE_ENV !== "development") {
    //   return null;
    // }
    console.warn.apply(console, rest);
}

// For web, only few attribute is supported
const propNamesRemap = {
    class: 'className',
    className: 'className',
    'xlink:href': 'href',
    strokeWidth: 'strokeWidth',
    'stroke-width': 'strokeWidth',
    strokeOpacity: 'strokeOpacity',
    'stroke-opacity': 'strokeOpacity',
    strokeLinecap: 'strokeLinecap',
    'stroke-linecap': 'strokeLinecap',
    strokeLinejoin: 'strokeLinejoin',
    'stroke-linejoin': 'strokeLinejoin',
    strokeDasharray: 'strokeDasharray',
    'stroke-dasharray': 'strokeDasharray',
    strokeDashoffset: 'strokeDashoffset',
    'stroke-dashoffset': 'strokeDashoffset',
    strokeMiterlimit: 'strokeMiterlimit',
    'stroke-miterlimit': 'strokeMiterlimit',
    'transform-origin': 'transform-origin',
    style: null,
};
const convertRunner = createConvertReactProps(propNamesRemap);
const filterNode = (node) => node.tagName !== 'title';
/**
 * Travel children node
 */
const renderChildren = (nodes, parentKey = '#', namespace = '@') => {
    const filteredNodes = nodes.filter(filterNode);
    return filteredNodes.map((node, index) => {
        const { tagName, attrs, children } = node;
        const nodeKey = `${parentKey}/$${tagName}_${index}`;
        let childrenNodes = [];
        if (children && children.length > 0) {
            childrenNodes = renderChildren(children, nodeKey, namespace);
        }
        const _props = convertRunner(attrs, {
            key: nodeKey,
        });
        // Rendering svg contenti n
        if (_props.id) {
            _props.id = namespace + _props.id;
        }
        if (_props.href) {
            _props.href = '#' + namespace + String(_props.href).substring(1);
        }
        return react.createElement(tagName, _props, ...childrenNodes);
    });
};

const InternalWebIcon = function (props) {
    const { ref: svgRef, variantsMap, defaultVariant, resolveType, content, map, familyName, name, variant, size, color, colorize = true, fontSize, lineHeight, style: bakStyle = {}, children, debug } = props, restProps = __rest(props, ["ref", "variantsMap", "defaultVariant", "resolveType", "content", "map", "familyName", "name", "variant", "size", "color", "colorize", "fontSize", "lineHeight", "style", "children", "debug"]);
    const elmNs = react.useMemo(() => `sik-${createRandomId()}`, []);
    const svgContent = getContentFromIconProps({
        variantsMap,
        defaultVariant,
        resolveType,
        content,
        map,
        name,
        variant,
    });
    const { attrs: svgAttrs, data: svgData = [] } = svgContent || {};
    const elements = react.useMemo(() => renderChildren(svgData, '#' + elmNs, `@${elmNs}:`), [svgData, elmNs]);
    if (debug) {
        console.debug(`Icon render. id='%s', name='${name}', variant='${variant}', props=%o`, props.id, props);
    }
    if (!svgContent) {
        if (debug) {
            if (variant && name) {
                showDebugWarning(`Icon was not found by given name '${name}' and variant '${variant}'`);
            }
            else if (name) {
                showDebugWarning(`Icon was not found by given name '${name}'`);
            }
        }
        return null;
    }
    const _a = svgAttrs || {}, { fill, stroke, width: svgWidth, height: svgHeight } = _a, restAttrs = __rest(_a, ["fill", "stroke", "width", "height"]);
    const viewBox = getViewboxValue(svgContent);
    // Allowing all additional props from external for html.
    const iconProps = Object.assign({}, restProps);
    const attrProps = convertRunner(restAttrs, {}, { allowNonWhitelistProp: false });
    const internalProps = Object.assign(Object.assign(Object.assign(Object.assign({ fill,
        stroke }, attrProps), { viewBox }), iconProps), { 'data-sik-ns': elmNs });
    if (fill !== 'none' && colorize) {
        internalProps.fill = PRIMARY_CURRENT_COLOR;
    }
    // For web, it does not support array based styles
    const internalStyle = {};
    if (color && colorize) {
        // For some iconset, they use stroke to styling and cannot use fill properties
        internalStyle.color = color;
    }
    if (filterNonEmptyString(svgWidth)) {
        internalProps.width = svgWidth;
    }
    if (filterNonEmptyString(svgHeight)) {
        internalProps.height = svgHeight;
    }
    if (filterNonEmptyString(size)) {
        internalProps.width = appendUnit(size);
        internalProps.height = appendUnit(size);
    }
    if (filterNonEmptyString(fontSize)) {
        internalProps.width = fontSize;
        internalProps.height = fontSize;
        internalStyle.fontSize = fontSize;
        internalStyle.lineHeight = fontSize;
    }
    if (filterNonEmptyString(lineHeight)) {
        internalStyle.lineHeight = lineHeight;
    }
    internalProps.style = internalStyle;
    if (bakStyle) {
        internalProps.style = Object.assign(Object.assign({}, internalStyle), bakStyle);
    }
    return react.createElement('svg', Object.assign({ ref: svgRef }, internalProps), elements, children);
};
InternalWebIcon.displayName = 'WebIcon';
const WebIcon = InternalWebIcon;

function createIconsetFactory(options, BaseIconComponent) {
    const { familyName, resolveType = ResolveType.VariantMap, defaultVariant, variant = defaultVariant } = options;
    let componentName = `${familyName}`;
    if (resolveType === ResolveType.ContentMap) {
        componentName = `${familyName}-${variant}`;
    }
    let displayName = `IconsetFamily(${componentName})`;
    if (resolveType === ResolveType.ContentMap) {
        displayName = `IconsetVariant(${componentName})`;
    }
    const Iconset = react.memo((props) => {
        const { ref, name } = props, restProps = __rest(props, ["ref", "name"]); // select target variant or assume there is no varaint from iconsmap data
        const content = getContentFromIconProps(Object.assign({ name, map: props.map, resolveType: props.resolveType, variant: props.variant, variantsMap: props.variantsMap, defaultVariant: props.defaultVariant, content: props.content }, options));
        if (!content) {
            console.warn(`Icon '${name}' not found from iconset ${componentName}.`);
            return null;
        }
        const otherProps = {};
        return react.createElement(BaseIconComponent, Object.assign(Object.assign(Object.assign(Object.assign({ ref }, options), otherProps), restProps), { resolveType: ResolveType.Content, content }));
    });
    Iconset.displayName = displayName;
    return Iconset;
}

function createWebIconset(options) {
    return createIconsetFactory(options, WebIcon);
}

function createWebFamily(options) {
    const { familyName, variantsMap } = options, rest = __rest(options, ["familyName", "variantsMap"]);
    return createWebIconset(Object.assign({ resolveType: ResolveType.VariantMap, familyName,
        variantsMap }, rest));
}

/**
 * Create renderable icon by content
 * @param {IconSVG} content;
 * @returns {React.ComponentType<IconBaseProps>}
 */
const createWebIcon = (content) => {
    return react.memo((props) => {
        return react.createElement(WebIcon, Object.assign({ resolveType: ResolveType.Content, content }, props));
    });
};

function createWebVariantsMap(options) {
    const { familyName, variantsMap, variantNames = [] } = options, rest = __rest(options, ["familyName", "variantsMap", "variantNames"]);
    return variantNames.reduce((output, variantName) => {
        const variantIconset = createWebIconset(Object.assign({ resolveType: ResolveType.ContentMap, familyName, map: variantsMap[variantName], variant: variantName }, rest));
        return Object.assign(Object.assign({}, output), { [variantName]: variantIconset });
    }, {});
}

/**
 * Render svg data within in <symbol>
 */
const WebIconContent = react.forwardRef((props, svgRef) => {
    const { variantsMap, defaultVariant, resolveType, content, map, familyName, name, as = 'symbol', variant, children } = props, restProps = __rest(props, ["variantsMap", "defaultVariant", "resolveType", "content", "map", "familyName", "name", "as", "variant", "children"]);
    const elmNs = react.useMemo(() => `sik-${createRandomId()}`, []);
    const svgContent = getContentFromIconProps({
        variantsMap,
        defaultVariant,
        resolveType,
        content,
        map,
        name,
        variant,
    });
    const { attrs = {}, data: svgData = [] } = svgContent || {};
    const elements = react.useMemo(() => renderChildren(svgData, '#', `@${elmNs}:`), [svgData]);
    if (!svgContent) {
        if (variant && name) {
            showDebugWarning(`IconContent was not found by given name '${name}' and variant '${variant}'`);
        }
        else if (name) {
            showDebugWarning(`IconContent was not found by given name '${name}'`);
        }
        return null;
    }
    return react.createElement(as, Object.assign({ ref: svgRef, viewBox: attrs.viewBox }, restProps), elements, children);
});

const Icon = WebIcon;

exports.Icon = Icon;
exports.IconContent = WebIconContent;
exports.createFamily = createWebFamily;
exports.createIconComponent = createWebIcon;
exports.createIconset = createWebIconset;
exports.createIconsetFactory = createIconsetFactory;
exports.createVariantsMap = createWebVariantsMap;
exports.default = Icon;
